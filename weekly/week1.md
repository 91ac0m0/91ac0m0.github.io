### NOV week1

这周主要在看前段时间 hnctf 的几道题(yellowgot，ret2csu，fmtstr_level2)，大部分是见过的知识点，但是初见时侯忽略一些细节，或者没有把握到关键，这回借机总结一下，然后不要好高骛远吧。

#### 动态链接、延迟绑定、plt&got

我们假设有两个程序a、b依赖于相同的模块 c ，如果a、b两个文件中都包含了 c，c 就在磁盘里有两个相同的备份，占用磁盘空间，运行时候也会加载两份相同的 c 到内存，略显多余。**动态链接**把公共的部分 c 单独提出来，类比于点击链接跳转，就能节省时间和空间。（😳 以前看到 pie 需要泄露地址绕过，动态链接也需要泄露函数地址来处理，以为它们有什么关联，现在才知道二者分别针对定义、未定义的函数）

**延迟绑定**用来进一步缩短程序的加载时间，在第一次调用函数的时候才寻找函数的地址并将地址记录起来，之后的调用就不需要再次寻找就能直接跳转。例如：
第一处 printf 执行之前的 got 表为
```bash
[0x404018] printf@GLIBC_2.2.5 -> 0x401030 ◂— endbr64
```
第一次 printf 执行之后的 got 表为
```bash
[0x404018] printf@GLIBC_2.2.5 -> 0x7ffff7e24c90 (printf) ◂— endbr64
```

**plt&got**查找函数地址的顺序是：

call plt -> got 里面没有 -> 查找并填入

call plt -> got 表里面有 -> 直接跳转

#### 常见的保护的特点

**pie**：代码、数据的地址随机 (text，data，bss)，静态调试里看到的地址大概就不能用到了

**NX**：堆、栈、bss 不可执行，shellcode 得写到除了堆栈、bss 的其他地方才能执行

**canary**：在 ret 之前增加检验，可以通过泄露 canary 的值，或者修改 `stack_chk_fail` 绕

#### 格式化字符串地址任意写

`[addr]%mc%k$hhn` 把m存入栈上偏移为k的单元（如果是地址就是所指向的单元），每次存1字节。其中`addr` 为目标地址，`%mc`表示输出m字节，`k$` 表示偏移， `%hhn` 表示写入一个字节大小。fmtstr_payload 的构造就类似于这种：

`[addr][addr][addr][addr]%mc%k$hhn%mc%k$hhn%mc%k$hhn%mc%k$hhn`

#### 碎碎念

- 好奇看了radare2，听说这样对学习来说更有帮助😭，困难不在于记住命令，而是这个软件没有f5，我是真的看不下去汇编，可能过段时间会好好学一下，也许亲自写过就会更容易读懂
- 暂时碰到的ROP链感觉比我想像得好写一些，重点是把流程理清楚
- 下周可能会开始看一下这个比赛的堆题